type Parser {
  lex: Lexer
  idx: i32
  bck: Token
  cur: Token
  bag: DiagnosticBag
}

func Parser(text: str, len: i32): Parser {
  return new Parser { lex: Lexer(text, len) }
}

// set the back token of the parser to the current, and the current to the next
func (this: *Parser) fetch_tok(): Token {
  (*this).bck = (*this).cur
  return (*this).cur = (&(*this).lex).next_tok()
}

func (this: *Parser) is_ok(): bool {
  return (*this).bag.len == 0
}

// returns the token that the parser is looking to
func (this: *Parser) cur(): Token {
  return (*this).cur
}

// returns the token that the parser is looking to
func (this: *Parser) back(): Token {
  return (*this).bck
}

func (this: *Parser) report(msg: str) {
  (&(*this).bag).report(msg, this.cur().pos)
}

// returns true whether the current token's kind is equals to `kind`
func (this: *Parser) match(kind: TokenKind): bool {
  const match = this.cur().kind == kind
  if match { this.fetch_tok() }
  
  return match
}

func (this: *Parser) match_val(out: *Node): bool {
  *out = this.cur() as Node
  return this.match(TokenKind.identifier) | this.match(TokenKind.digit)
}

func (this: *Parser) match_primary_ops(): bool {
  return this.match(TokenKind.plus) | this.match(TokenKind.minus)
}

func (this: *Parser) match_sub_ops(): bool {
  return this.match(TokenKind.star) | this.match(TokenKind.slash)
}

func (this: *Parser) match_inpar_expr(out: *Node): bool {
  if !this.match(TokenKind.open) { return false }
  
  *out = this.expect_expr(TokenKind.close)
  return true
}

func (this: *Parser) match_term(out: *Node): bool {
  return this.match_val(out) | this.match_inpar_expr(out)
}

func (this: *Parser) expect_term(): Node {
  var result = Node()
  const match = this.match_term(&result)
  if !match { this.report("expected term here") }

  return result
}

func (this: *Parser) match_factor(out: *Node): bool {
  if !this.match_term(out) { return false }

  while this.match_sub_ops() {
    const op = this.back()
    *out = BinaryNode(*out, this.expect_term(), op.kind) as Node
  }

  return true
}

func (this: *Parser) expect_factor(): Node {
  var result = Node()
  if !this.match_factor(&result) { this.report("expected factor here") }

  return result
}

func (this: *Parser) expect_expr(delimiter: TokenKind): Node {
  var left = Node()
  if this.match_factor(&left) {
    // checking for + -
    while this.match_primary_ops() {
      const op = this.back()
      left = BinaryNode(left, this.expect_factor(), op.kind) as Node // right
    }

    // checking for the end of the expression
    if delimiter != TokenKind.none & !this.match(delimiter) {
      this.report("expected '" + delimiter.to_str() + "' at the end of expression here")
    }
    
    this.fetch_tok()
  } else {
    this.report("expected expression here")
  }

  return left
}

// parses the expression
func (this: *Parser) parse(): ParseErr!Node {
  // fetching first token
  this.fetch_tok()
  
  const expr = this.expect_expr(TokenKind.none)
  if this.is_ok() { return expr }
  
  return ParseErr.CouldNotParse
}